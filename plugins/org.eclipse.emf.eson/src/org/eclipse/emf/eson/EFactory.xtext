grammar org.eclipse.emf.eson.EFactory hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate eFactory "http://www.eclipse.org/emf/eson/EFactory"

Factory:
	(imports += NamespaceImport)*
	(epackages+=PackageImport)*
	(annotations+=Annotation)*
	root=NewObject;
	
PackageImport:
// TODO Validation rule with "deprecated" warning for 'use', now that we have 'import' instead 
'use' ePackage = [ecore::EPackage|QualifiedName] '.*';
// TODO like the *.Xtext grammar itself does, support namespace and package name based (try the 'import' above!) + maybe support an "as" syntax

NamespaceImport:
	'import' importedNamespace = QualifiedNameWithWildcard	
	// TODO Content Assist for EPackage .. but one COULD also import other named NewObject / EObject, instead of EPackages.. hm. As EPackage will be much more common, just support that.	
;

Annotation:
	CustomNameMapping;

// TODO further consider if name mapping is best put in-line into objects.. it would have to repeat in every file..
// logically this rather belongs into an external mapping, like HUTN's Configuration (HutnConfig), or even better directly into an Xcore as annotations 

CustomNameMapping:
	"@Name" "{" eClass=[ecore::EClass|QualifiedName] "=" nameFeature=[ecore::EAttribute] "}" ;
	
Feature:
	eFeature=[ecore::EStructuralFeature] ":" (value=Value)? ;
	// value isn't really optional semantically of course
	// but because it may be missing while typing, this works out much better in practice like this
	// the EFactoryJavaValidator flags it up if it's really missing
	// without this, there are confusing parsing errors, the proposal provider doesn't work as it should, etc.
	
NewObject:
	eClass=[ecore::EClass|QualifiedName] (name=ANY)? "{"
		(features += Feature)*
	"}";

Value:
	// The two (!) Syntactic Predicates => are needed here to solve "Decision can match input such as "RULE_ID '.' RULE_ID {RULE_STRING..RULE_DATE, '}', '['..'false'}" using multiple alternatives: 3, 4"
	MultiValue | Attribute | =>Containment | =>Reference;

Attribute: EnumAttribute | AnyAttribute;

MultiValue:
	{MultiValue} "[" (values += Value)* "]" ;

Reference:
	// NOTE we ref. an EObject, and not an [NewObject].. this EObject is always the
	// respective "real" EObject, in the derived state if its a reference to something
	// in an EFactory resource, or a reference to an existing non-EFactory EObject, 
	// e.g. in an integration scenario with other Xtext grammars.
	value = [ecore::EObject|QualifiedName];
	
Containment:
	value = NewObject;

EnumAttribute: ":" value = [ecore::EEnumLiteral]; // TODO better for the lexer/parser if we use another character than ":" to mark enums.. say # (like Symbols in Smalltalk) ?

AnyAttribute: value = ANY;

QualifiedNameWithWildcard: QualifiedName '.*'? ;
QualifiedName: ID (=>'.' ID)*;

// Due to historic reasons in a closed source an in-house product which uses ESON
// we need to add ',' and '-' to be allowed in IDs.  We also permit ID starting with digits, via the ValidID: ID | LONG above.
// (NOTE: This terminal must be named 'ID' as well, not some new ID2 - unless you write a new ValueConverter for it.)
terminal ID         : '^'? ('a'..'z'|'A'..'Z'|'_'|','|'-'|'0'..'9')+ ;
terminal ID_WITHDOT : '^'? ('a'..'z'|'A'..'Z'|'_'|','|'-'|'0'..'9'|'.')+ ;
terminal ANY returns ecore::EJavaObject: STRING | ID_WITHDOT; 


// Copy/pasted from org.eclipse.xtext.common.Terminals (partial) 
// We do this, instead of just "grammar .. with org.eclipse.xtext.common.Terminals" on top
// just to avoid Xtext generation errors such as "The following token definitions can never be matched because prior tokens match the same input: RULE_INT,RULE_STRING"

terminal STRING	: 
			'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
			"'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
		; 
		
terminal ML_COMMENT	: '/*' -> '*/';
terminal SL_COMMENT 	: '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS			: (' '|'\t'|'\r'|'\n')+;

terminal ANY_OTHER: .;
