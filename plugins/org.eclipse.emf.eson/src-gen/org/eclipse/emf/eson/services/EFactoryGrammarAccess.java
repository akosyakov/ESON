/*
* generated by Xtext
*/
package org.eclipse.emf.eson.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class EFactoryGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class FactoryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Factory");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cImportsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cImportsNamespaceImportParserRuleCall_0_0 = (RuleCall)cImportsAssignment_0.eContents().get(0);
		private final Assignment cEpackagesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEpackagesPackageImportParserRuleCall_1_0 = (RuleCall)cEpackagesAssignment_1.eContents().get(0);
		private final Assignment cAnnotationsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAnnotationsAnnotationParserRuleCall_2_0 = (RuleCall)cAnnotationsAssignment_2.eContents().get(0);
		private final Assignment cRootAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRootNewObjectParserRuleCall_3_0 = (RuleCall)cRootAssignment_3.eContents().get(0);
		
		//Factory:
		//	imports+=NamespaceImport* epackages+=PackageImport* annotations+=Annotation* root=NewObject;
		public ParserRule getRule() { return rule; }

		//imports+=NamespaceImport* epackages+=PackageImport* annotations+=Annotation* root=NewObject
		public Group getGroup() { return cGroup; }

		//imports+=NamespaceImport*
		public Assignment getImportsAssignment_0() { return cImportsAssignment_0; }

		//NamespaceImport
		public RuleCall getImportsNamespaceImportParserRuleCall_0_0() { return cImportsNamespaceImportParserRuleCall_0_0; }

		//epackages+=PackageImport*
		public Assignment getEpackagesAssignment_1() { return cEpackagesAssignment_1; }

		//PackageImport
		public RuleCall getEpackagesPackageImportParserRuleCall_1_0() { return cEpackagesPackageImportParserRuleCall_1_0; }

		//annotations+=Annotation*
		public Assignment getAnnotationsAssignment_2() { return cAnnotationsAssignment_2; }

		//Annotation
		public RuleCall getAnnotationsAnnotationParserRuleCall_2_0() { return cAnnotationsAnnotationParserRuleCall_2_0; }

		//root=NewObject
		public Assignment getRootAssignment_3() { return cRootAssignment_3; }

		//NewObject
		public RuleCall getRootNewObjectParserRuleCall_3_0() { return cRootNewObjectParserRuleCall_3_0; }
	}

	public class PackageImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PackageImport");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cUseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cEPackageAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cEPackageEPackageCrossReference_1_0 = (CrossReference)cEPackageAssignment_1.eContents().get(0);
		private final RuleCall cEPackageEPackageQualifiedNameParserRuleCall_1_0_1 = (RuleCall)cEPackageEPackageCrossReference_1_0.eContents().get(1);
		private final Keyword cFullStopAsteriskKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//PackageImport: // TODO Validation rule with "deprecated" warning for 'use', now that we have 'import' instead 
		//	"use" ePackage=[ecore::EPackage|QualifiedName] ".*";
		public ParserRule getRule() { return rule; }

		//// TODO Validation rule with "deprecated" warning for 'use', now that we have 'import' instead 
		//"use" ePackage=[ecore::EPackage|QualifiedName] ".*"
		public Group getGroup() { return cGroup; }

		//// TODO Validation rule with "deprecated" warning for 'use', now that we have 'import' instead 
		//"use"
		public Keyword getUseKeyword_0() { return cUseKeyword_0; }

		//ePackage=[ecore::EPackage|QualifiedName]
		public Assignment getEPackageAssignment_1() { return cEPackageAssignment_1; }

		//[ecore::EPackage|QualifiedName]
		public CrossReference getEPackageEPackageCrossReference_1_0() { return cEPackageEPackageCrossReference_1_0; }

		//QualifiedName
		public RuleCall getEPackageEPackageQualifiedNameParserRuleCall_1_0_1() { return cEPackageEPackageQualifiedNameParserRuleCall_1_0_1; }

		//".*"
		public Keyword getFullStopAsteriskKeyword_2() { return cFullStopAsteriskKeyword_2; }
	}

	public class NamespaceImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NamespaceImport");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cImportedNamespaceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0 = (RuleCall)cImportedNamespaceAssignment_1.eContents().get(0);
		
		//// TODO like the *.Xtext grammar itself does, support namespace and package name based (try the 'import' above!) + maybe support an "as" syntax
		//// TODO Content Assist for EPackage .. but one COULD also import other named NewObject / EObject, instead of EPackages.. hm. As EPackage will be much more common, just support that.	
		//NamespaceImport:
		//	"import" importedNamespace=QualifiedNameWithWildcard;
		public ParserRule getRule() { return rule; }

		//"import" importedNamespace=QualifiedNameWithWildcard
		public Group getGroup() { return cGroup; }

		//"import"
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }

		//importedNamespace=QualifiedNameWithWildcard
		public Assignment getImportedNamespaceAssignment_1() { return cImportedNamespaceAssignment_1; }

		//QualifiedNameWithWildcard
		public RuleCall getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0() { return cImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0; }
	}

	public class AnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Annotation");
		private final RuleCall cCustomNameMappingParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Annotation:
		//	CustomNameMapping;
		public ParserRule getRule() { return rule; }

		//CustomNameMapping
		public RuleCall getCustomNameMappingParserRuleCall() { return cCustomNameMappingParserRuleCall; }
	}

	public class CustomNameMappingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CustomNameMapping");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNameKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cEClassAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cEClassEClassCrossReference_2_0 = (CrossReference)cEClassAssignment_2.eContents().get(0);
		private final RuleCall cEClassEClassQualifiedNameParserRuleCall_2_0_1 = (RuleCall)cEClassEClassCrossReference_2_0.eContents().get(1);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cNameFeatureAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final CrossReference cNameFeatureEAttributeCrossReference_4_0 = (CrossReference)cNameFeatureAssignment_4.eContents().get(0);
		private final RuleCall cNameFeatureEAttributeIDTerminalRuleCall_4_0_1 = (RuleCall)cNameFeatureEAttributeCrossReference_4_0.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//// TODO further consider if name mapping is best put in-line into objects.. it would have to repeat in every file..
		//// logically this rather belongs into an external mapping, like HUTN's Configuration (HutnConfig), or even better directly into an Xcore as annotations 
		//CustomNameMapping:
		//	"@Name" "{" eClass=[ecore::EClass|QualifiedName] "=" nameFeature=[ecore::EAttribute] "}";
		public ParserRule getRule() { return rule; }

		//"@Name" "{" eClass=[ecore::EClass|QualifiedName] "=" nameFeature=[ecore::EAttribute] "}"
		public Group getGroup() { return cGroup; }

		//"@Name"
		public Keyword getNameKeyword_0() { return cNameKeyword_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//eClass=[ecore::EClass|QualifiedName]
		public Assignment getEClassAssignment_2() { return cEClassAssignment_2; }

		//[ecore::EClass|QualifiedName]
		public CrossReference getEClassEClassCrossReference_2_0() { return cEClassEClassCrossReference_2_0; }

		//QualifiedName
		public RuleCall getEClassEClassQualifiedNameParserRuleCall_2_0_1() { return cEClassEClassQualifiedNameParserRuleCall_2_0_1; }

		//"="
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }

		//nameFeature=[ecore::EAttribute]
		public Assignment getNameFeatureAssignment_4() { return cNameFeatureAssignment_4; }

		//[ecore::EAttribute]
		public CrossReference getNameFeatureEAttributeCrossReference_4_0() { return cNameFeatureEAttributeCrossReference_4_0; }

		//ID
		public RuleCall getNameFeatureEAttributeIDTerminalRuleCall_4_0_1() { return cNameFeatureEAttributeIDTerminalRuleCall_4_0_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}

	public class FeatureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Feature");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cEFeatureAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cEFeatureEStructuralFeatureCrossReference_0_0 = (CrossReference)cEFeatureAssignment_0.eContents().get(0);
		private final RuleCall cEFeatureEStructuralFeatureIDTerminalRuleCall_0_0_1 = (RuleCall)cEFeatureEStructuralFeatureCrossReference_0_0.eContents().get(1);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueValueParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//Feature:
		//	eFeature=[ecore::EStructuralFeature] ":" value=Value?;
		public ParserRule getRule() { return rule; }

		//eFeature=[ecore::EStructuralFeature] ":" value=Value?
		public Group getGroup() { return cGroup; }

		//eFeature=[ecore::EStructuralFeature]
		public Assignment getEFeatureAssignment_0() { return cEFeatureAssignment_0; }

		//[ecore::EStructuralFeature]
		public CrossReference getEFeatureEStructuralFeatureCrossReference_0_0() { return cEFeatureEStructuralFeatureCrossReference_0_0; }

		//ID
		public RuleCall getEFeatureEStructuralFeatureIDTerminalRuleCall_0_0_1() { return cEFeatureEStructuralFeatureIDTerminalRuleCall_0_0_1; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//value=Value?
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//Value
		public RuleCall getValueValueParserRuleCall_2_0() { return cValueValueParserRuleCall_2_0; }
	}

	public class NewObjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NewObject");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cEClassAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cEClassEClassCrossReference_0_0 = (CrossReference)cEClassAssignment_0.eContents().get(0);
		private final RuleCall cEClassEClassQualifiedNameParserRuleCall_0_0_1 = (RuleCall)cEClassEClassCrossReference_0_0.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameANYTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cFeaturesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cFeaturesFeatureParserRuleCall_3_0 = (RuleCall)cFeaturesAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// value isn't really optional semantically of course
		//// but because it may be missing while typing, this works out much better in practice like this
		//// the EFactoryJavaValidator flags it up if it's really missing
		//// without this, there are confusing parsing errors, the proposal provider doesn't work as it should, etc.
		//NewObject:
		//	eClass=[ecore::EClass|QualifiedName] name=ANY? "{" features+=Feature* "}";
		public ParserRule getRule() { return rule; }

		//eClass=[ecore::EClass|QualifiedName] name=ANY? "{" features+=Feature* "}"
		public Group getGroup() { return cGroup; }

		//eClass=[ecore::EClass|QualifiedName]
		public Assignment getEClassAssignment_0() { return cEClassAssignment_0; }

		//[ecore::EClass|QualifiedName]
		public CrossReference getEClassEClassCrossReference_0_0() { return cEClassEClassCrossReference_0_0; }

		//QualifiedName
		public RuleCall getEClassEClassQualifiedNameParserRuleCall_0_0_1() { return cEClassEClassQualifiedNameParserRuleCall_0_0_1; }

		//name=ANY?
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ANY
		public RuleCall getNameANYTerminalRuleCall_1_0() { return cNameANYTerminalRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//features+=Feature*
		public Assignment getFeaturesAssignment_3() { return cFeaturesAssignment_3; }

		//Feature
		public RuleCall getFeaturesFeatureParserRuleCall_3_0() { return cFeaturesFeatureParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Value");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cMultiValueParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAttributeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cContainmentParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cReferenceParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Value: // The two (!) Syntactic Predicates => are needed here to solve "Decision can match input such as "RULE_ID '.' RULE_ID {RULE_STRING..RULE_DATE, '}', '['..'false'}" using multiple alternatives: 3, 4"
		//	MultiValue | Attribute | => Containment | => Reference;
		public ParserRule getRule() { return rule; }

		//// The two (!) Syntactic Predicates => are needed here to solve "Decision can match input such as "RULE_ID '.' RULE_ID {RULE_STRING..RULE_DATE, '}', '['..'false'}" using multiple alternatives: 3, 4"
		//MultiValue | Attribute | => Containment | => Reference
		public Alternatives getAlternatives() { return cAlternatives; }

		//// The two (!) Syntactic Predicates => are needed here to solve "Decision can match input such as "RULE_ID '.' RULE_ID {RULE_STRING..RULE_DATE, '}', '['..'false'}" using multiple alternatives: 3, 4"
		//MultiValue
		public RuleCall getMultiValueParserRuleCall_0() { return cMultiValueParserRuleCall_0; }

		//Attribute
		public RuleCall getAttributeParserRuleCall_1() { return cAttributeParserRuleCall_1; }

		//=> Containment
		public RuleCall getContainmentParserRuleCall_2() { return cContainmentParserRuleCall_2; }

		//=> Reference
		public RuleCall getReferenceParserRuleCall_3() { return cReferenceParserRuleCall_3; }
	}

	public class AttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Attribute");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEnumAttributeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAnyAttributeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Attribute:
		//	EnumAttribute | AnyAttribute;
		public ParserRule getRule() { return rule; }

		//EnumAttribute | AnyAttribute
		public Alternatives getAlternatives() { return cAlternatives; }

		//EnumAttribute
		public RuleCall getEnumAttributeParserRuleCall_0() { return cEnumAttributeParserRuleCall_0; }

		//AnyAttribute
		public RuleCall getAnyAttributeParserRuleCall_1() { return cAnyAttributeParserRuleCall_1; }
	}

	public class MultiValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cMultiValueAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValuesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValuesValueParserRuleCall_2_0 = (RuleCall)cValuesAssignment_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//MultiValue:
		//	{MultiValue} "[" values+=Value* "]";
		public ParserRule getRule() { return rule; }

		//{MultiValue} "[" values+=Value* "]"
		public Group getGroup() { return cGroup; }

		//{MultiValue}
		public Action getMultiValueAction_0() { return cMultiValueAction_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }

		//values+=Value*
		public Assignment getValuesAssignment_2() { return cValuesAssignment_2; }

		//Value
		public RuleCall getValuesValueParserRuleCall_2_0() { return cValuesValueParserRuleCall_2_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}

	public class ReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Reference");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cValueEObjectCrossReference_0 = (CrossReference)cValueAssignment.eContents().get(0);
		private final RuleCall cValueEObjectQualifiedNameParserRuleCall_0_1 = (RuleCall)cValueEObjectCrossReference_0.eContents().get(1);
		
		//Reference: // NOTE we ref. an EObject, and not an [NewObject].. this EObject is always the
		//// respective "real" EObject, in the derived state if its a reference to something
		//// in an EFactory resource, or a reference to an existing non-EFactory EObject, 
		//// e.g. in an integration scenario with other Xtext grammars.
		//	value=[ecore::EObject|QualifiedName];
		public ParserRule getRule() { return rule; }

		//// NOTE we ref. an EObject, and not an [NewObject].. this EObject is always the
		//// respective "real" EObject, in the derived state if its a reference to something
		//// in an EFactory resource, or a reference to an existing non-EFactory EObject, 
		//// e.g. in an integration scenario with other Xtext grammars.
		//value=[ecore::EObject|QualifiedName]
		public Assignment getValueAssignment() { return cValueAssignment; }

		//[ecore::EObject|QualifiedName]
		public CrossReference getValueEObjectCrossReference_0() { return cValueEObjectCrossReference_0; }

		//QualifiedName
		public RuleCall getValueEObjectQualifiedNameParserRuleCall_0_1() { return cValueEObjectQualifiedNameParserRuleCall_0_1; }
	}

	public class ContainmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Containment");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueNewObjectParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//Containment:
		//	value=NewObject;
		public ParserRule getRule() { return rule; }

		//value=NewObject
		public Assignment getValueAssignment() { return cValueAssignment; }

		//NewObject
		public RuleCall getValueNewObjectParserRuleCall_0() { return cValueNewObjectParserRuleCall_0; }
	}

	public class EnumAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumAttribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cValueEEnumLiteralCrossReference_1_0 = (CrossReference)cValueAssignment_1.eContents().get(0);
		private final RuleCall cValueEEnumLiteralIDTerminalRuleCall_1_0_1 = (RuleCall)cValueEEnumLiteralCrossReference_1_0.eContents().get(1);
		
		//// TODO better for the lexer/parser if we use another character than ":" to mark enums.. say # (like Symbols in Smalltalk) ?
		//EnumAttribute:
		//	":" value=[ecore::EEnumLiteral];
		public ParserRule getRule() { return rule; }

		//":" value=[ecore::EEnumLiteral]
		public Group getGroup() { return cGroup; }

		//":"
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }

		//value=[ecore::EEnumLiteral]
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//[ecore::EEnumLiteral]
		public CrossReference getValueEEnumLiteralCrossReference_1_0() { return cValueEEnumLiteralCrossReference_1_0; }

		//ID
		public RuleCall getValueEEnumLiteralIDTerminalRuleCall_1_0_1() { return cValueEEnumLiteralIDTerminalRuleCall_1_0_1; }
	}

	public class AnyAttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AnyAttribute");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueANYTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//AnyAttribute:
		//	value=ANY;
		public ParserRule getRule() { return rule; }

		//value=ANY
		public Assignment getValueAssignment() { return cValueAssignment; }

		//ANY
		public RuleCall getValueANYTerminalRuleCall_0() { return cValueANYTerminalRuleCall_0; }
	}

	public class QualifiedNameWithWildcardElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualifiedNameWithWildcard");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cQualifiedNameParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopAsteriskKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//QualifiedNameWithWildcard:
		//	QualifiedName ".*"?;
		public ParserRule getRule() { return rule; }

		//QualifiedName ".*"?
		public Group getGroup() { return cGroup; }

		//QualifiedName
		public RuleCall getQualifiedNameParserRuleCall_0() { return cQualifiedNameParserRuleCall_0; }

		//".*"?
		public Keyword getFullStopAsteriskKeyword_1() { return cFullStopAsteriskKeyword_1; }
	}

	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//QualifiedName:
		//	ID ("." ID)*;
		public ParserRule getRule() { return rule; }

		//ID ("." ID)*
		public Group getGroup() { return cGroup; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//(=> "." ID)*
		public Group getGroup_1() { return cGroup_1; }

		//=> "."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}
	
	
	private final FactoryElements pFactory;
	private final PackageImportElements pPackageImport;
	private final NamespaceImportElements pNamespaceImport;
	private final AnnotationElements pAnnotation;
	private final CustomNameMappingElements pCustomNameMapping;
	private final FeatureElements pFeature;
	private final NewObjectElements pNewObject;
	private final ValueElements pValue;
	private final AttributeElements pAttribute;
	private final MultiValueElements pMultiValue;
	private final ReferenceElements pReference;
	private final ContainmentElements pContainment;
	private final EnumAttributeElements pEnumAttribute;
	private final AnyAttributeElements pAnyAttribute;
	private final QualifiedNameWithWildcardElements pQualifiedNameWithWildcard;
	private final QualifiedNameElements pQualifiedName;
	private final TerminalRule tID;
	private final TerminalRule tID_WITHDOT;
	private final TerminalRule tANY;
	private final TerminalRule tSTRING;
	private final TerminalRule tML_COMMENT;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tWS;
	private final TerminalRule tANY_OTHER;
	
	private final Grammar grammar;

	@Inject
	public EFactoryGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pFactory = new FactoryElements();
		this.pPackageImport = new PackageImportElements();
		this.pNamespaceImport = new NamespaceImportElements();
		this.pAnnotation = new AnnotationElements();
		this.pCustomNameMapping = new CustomNameMappingElements();
		this.pFeature = new FeatureElements();
		this.pNewObject = new NewObjectElements();
		this.pValue = new ValueElements();
		this.pAttribute = new AttributeElements();
		this.pMultiValue = new MultiValueElements();
		this.pReference = new ReferenceElements();
		this.pContainment = new ContainmentElements();
		this.pEnumAttribute = new EnumAttributeElements();
		this.pAnyAttribute = new AnyAttributeElements();
		this.pQualifiedNameWithWildcard = new QualifiedNameWithWildcardElements();
		this.pQualifiedName = new QualifiedNameElements();
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ID");
		this.tID_WITHDOT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ID_WITHDOT");
		this.tANY = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ANY");
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STRING");
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ML_COMMENT");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SL_COMMENT");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS");
		this.tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ANY_OTHER");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.eclipse.emf.eson.EFactory".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//Factory:
	//	imports+=NamespaceImport* epackages+=PackageImport* annotations+=Annotation* root=NewObject;
	public FactoryElements getFactoryAccess() {
		return pFactory;
	}
	
	public ParserRule getFactoryRule() {
		return getFactoryAccess().getRule();
	}

	//PackageImport: // TODO Validation rule with "deprecated" warning for 'use', now that we have 'import' instead 
	//	"use" ePackage=[ecore::EPackage|QualifiedName] ".*";
	public PackageImportElements getPackageImportAccess() {
		return pPackageImport;
	}
	
	public ParserRule getPackageImportRule() {
		return getPackageImportAccess().getRule();
	}

	//// TODO like the *.Xtext grammar itself does, support namespace and package name based (try the 'import' above!) + maybe support an "as" syntax
	//// TODO Content Assist for EPackage .. but one COULD also import other named NewObject / EObject, instead of EPackages.. hm. As EPackage will be much more common, just support that.	
	//NamespaceImport:
	//	"import" importedNamespace=QualifiedNameWithWildcard;
	public NamespaceImportElements getNamespaceImportAccess() {
		return pNamespaceImport;
	}
	
	public ParserRule getNamespaceImportRule() {
		return getNamespaceImportAccess().getRule();
	}

	//Annotation:
	//	CustomNameMapping;
	public AnnotationElements getAnnotationAccess() {
		return pAnnotation;
	}
	
	public ParserRule getAnnotationRule() {
		return getAnnotationAccess().getRule();
	}

	//// TODO further consider if name mapping is best put in-line into objects.. it would have to repeat in every file..
	//// logically this rather belongs into an external mapping, like HUTN's Configuration (HutnConfig), or even better directly into an Xcore as annotations 
	//CustomNameMapping:
	//	"@Name" "{" eClass=[ecore::EClass|QualifiedName] "=" nameFeature=[ecore::EAttribute] "}";
	public CustomNameMappingElements getCustomNameMappingAccess() {
		return pCustomNameMapping;
	}
	
	public ParserRule getCustomNameMappingRule() {
		return getCustomNameMappingAccess().getRule();
	}

	//Feature:
	//	eFeature=[ecore::EStructuralFeature] ":" value=Value?;
	public FeatureElements getFeatureAccess() {
		return pFeature;
	}
	
	public ParserRule getFeatureRule() {
		return getFeatureAccess().getRule();
	}

	//// value isn't really optional semantically of course
	//// but because it may be missing while typing, this works out much better in practice like this
	//// the EFactoryJavaValidator flags it up if it's really missing
	//// without this, there are confusing parsing errors, the proposal provider doesn't work as it should, etc.
	//NewObject:
	//	eClass=[ecore::EClass|QualifiedName] name=ANY? "{" features+=Feature* "}";
	public NewObjectElements getNewObjectAccess() {
		return pNewObject;
	}
	
	public ParserRule getNewObjectRule() {
		return getNewObjectAccess().getRule();
	}

	//Value: // The two (!) Syntactic Predicates => are needed here to solve "Decision can match input such as "RULE_ID '.' RULE_ID {RULE_STRING..RULE_DATE, '}', '['..'false'}" using multiple alternatives: 3, 4"
	//	MultiValue | Attribute | => Containment | => Reference;
	public ValueElements getValueAccess() {
		return pValue;
	}
	
	public ParserRule getValueRule() {
		return getValueAccess().getRule();
	}

	//Attribute:
	//	EnumAttribute | AnyAttribute;
	public AttributeElements getAttributeAccess() {
		return pAttribute;
	}
	
	public ParserRule getAttributeRule() {
		return getAttributeAccess().getRule();
	}

	//MultiValue:
	//	{MultiValue} "[" values+=Value* "]";
	public MultiValueElements getMultiValueAccess() {
		return pMultiValue;
	}
	
	public ParserRule getMultiValueRule() {
		return getMultiValueAccess().getRule();
	}

	//Reference: // NOTE we ref. an EObject, and not an [NewObject].. this EObject is always the
	//// respective "real" EObject, in the derived state if its a reference to something
	//// in an EFactory resource, or a reference to an existing non-EFactory EObject, 
	//// e.g. in an integration scenario with other Xtext grammars.
	//	value=[ecore::EObject|QualifiedName];
	public ReferenceElements getReferenceAccess() {
		return pReference;
	}
	
	public ParserRule getReferenceRule() {
		return getReferenceAccess().getRule();
	}

	//Containment:
	//	value=NewObject;
	public ContainmentElements getContainmentAccess() {
		return pContainment;
	}
	
	public ParserRule getContainmentRule() {
		return getContainmentAccess().getRule();
	}

	//// TODO better for the lexer/parser if we use another character than ":" to mark enums.. say # (like Symbols in Smalltalk) ?
	//EnumAttribute:
	//	":" value=[ecore::EEnumLiteral];
	public EnumAttributeElements getEnumAttributeAccess() {
		return pEnumAttribute;
	}
	
	public ParserRule getEnumAttributeRule() {
		return getEnumAttributeAccess().getRule();
	}

	//AnyAttribute:
	//	value=ANY;
	public AnyAttributeElements getAnyAttributeAccess() {
		return pAnyAttribute;
	}
	
	public ParserRule getAnyAttributeRule() {
		return getAnyAttributeAccess().getRule();
	}

	//QualifiedNameWithWildcard:
	//	QualifiedName ".*"?;
	public QualifiedNameWithWildcardElements getQualifiedNameWithWildcardAccess() {
		return pQualifiedNameWithWildcard;
	}
	
	public ParserRule getQualifiedNameWithWildcardRule() {
		return getQualifiedNameWithWildcardAccess().getRule();
	}

	//QualifiedName:
	//	ID ("." ID)*;
	public QualifiedNameElements getQualifiedNameAccess() {
		return pQualifiedName;
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}

	//// Due to historic reasons in a closed source an in-house product which uses ESON
	//// we need to add ',' and '-' to be allowed in IDs.  We also permit ID starting with digits, via the ValidID: ID | LONG above.
	//// (NOTE: This terminal must be named 'ID' as well, not some new ID2 - unless you write a new ValueConverter for it.)
	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_" | "," | "-" | "0".."9")+;
	public TerminalRule getIDRule() {
		return tID;
	} 

	//terminal ID_WITHDOT:
	//	"^"? ("a".."z" | "A".."Z" | "_" | "," | "-" | "0".."9" | ".")+;
	public TerminalRule getID_WITHDOTRule() {
		return tID_WITHDOT;
	} 

	//terminal ANY returns ecore::EJavaObject:
	//	STRING | ID_WITHDOT;
	public TerminalRule getANYRule() {
		return tANY;
	} 

	//// Copy/pasted from org.eclipse.xtext.common.Terminals (partial) 
	//// We do this, instead of just "grammar .. with org.eclipse.xtext.common.Terminals" on top
	//// just to avoid Xtext generation errors such as "The following token definitions can never be matched because prior tokens match the same input: RULE_INT,RULE_STRING"
	//terminal STRING:
	//	"\"" ("\\" . / * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\""))* "\"" | "\'" ("\\" .
	//	/ * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return tWS;
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return tANY_OTHER;
	} 
}
